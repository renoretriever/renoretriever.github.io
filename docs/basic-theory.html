<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>基礎理論 · Life is ...</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 基礎理論"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="基礎理論 · Life is ..."/><meta property="og:type" content="website"/><meta property="og:url" content="https://renoretriever.github.io//index.html"/><meta property="og:description" content="## 基礎理論"/><meta property="og:image" content="https://renoretriever.github.io/img/reno-site-min.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://renoretriever.github.io/img/reno-site-min.png"/><link rel="shortcut icon" href="/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/school-book.min.css"/><link rel="alternate" type="application/atom+xml" href="https://renoretriever.github.io/blog/atom.xml" title="Life is ... Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://renoretriever.github.io/blog/feed.xml" title="Life is ... Blog RSS Feed"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.9.0/dist/instantsearch.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.9.0/dist/instantsearch-theme-algolia.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.9.0"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">Life is ...</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/index.html" target="_self">Wiki</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><li class=""><a href="/docs/search.html" target="_self">Search</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">基礎理論</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="基礎理論"></a><a href="#基礎理論" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基礎理論</h2>
<h3><a class="anchor" aria-hidden="true" id="離散数学"></a><a href="#離散数学" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>離散数学</h3>
<ul>
<li><p>コンピュータ内部では、電流の有無や電圧の高低などによってデータを識別して処理</p>
<ul>
<li>0, 1 の組み合わせで表現
<ul>
<li>2 進数
<img src="any_decimal.png" alt=""></li>
</ul></li>
</ul></li>
<li><p>基数</p>
<ul>
<li>桁があがる数のこと
<ul>
<li>10 進数では、10 倍ずつ桁があがる</li>
<li>2 進数では、2 倍ずつあがるときに桁があがる</li>
</ul></li>
</ul></li>
<li><p>基数変換</p>
<ul>
<li>ある進数から別の進数に置き換えること</li>
<li>2 進数から 10 進数への変換
<ul>
<li><img src="basic_theory_2_to_10.png" alt=""></li>
</ul></li>
<li>10 進数から 2 進数への変換
<ul>
<li><img src="basic_theory_10_to_2.png" alt=""></li>
</ul></li>
<li>2 進数から 8 進数や 16 進数へ変換する
<ul>
<li><font color='red'>2 進数 3 桁分を 8 進数では 1 桁で表現</font></li>
<li><font color='red'>2 進数 4 桁分を 16 進数では 1 桁で表現</font></li>
<li>3 または 4 桁にならない場合には先頭に 0 を格納する</li>
<li><img src="basic_theory_2_to_8_16.png" alt=""></li>
</ul></li>
<li>8 進数や 16 進数から 2 進数へ変換する
<ul>
<li><font color='red'>8 進数 1 桁を 2 進数では 3 桁で表現</font></li>
<li><font color='red'>16 進数 1 桁を 2 進数では 4 桁で表現</font></li>
<li>3 または 4 桁にならない場合には先頭に 0 を格納する</li>
<li><img src="basic_theory_8_16_to_2.png" alt=""></li>
</ul></li>
</ul></li>
<li><p>文字コード</p></li>
<li><p>数値の表現</p>
<ul>
<li>コンピュータで処理を行うとき、限られたビット数で数値を表現することがある</li>
</ul>
<ol>
<li>10 進数の表現方法
<ul>
<li>BCD(Binary Coded Decimal)
<ul>
<li>2 進数を 4 桁使うことで 10 進数の考え方を取り入れて表現する方法</li>
<li>2 進化 10 進</li>
<li>メリット
<ul>
<li>10 進数を 1 桁ずつ表すため分かりやすい</li>
</ul></li>
<li>デメリット
<ul>
<li>正負の符号を表現できない</li>
<li>本来 16(2 の 4 乗) 種類の表現が可能な 4 ビットで 0 〜 9 までしか表現できない</li>
</ul></li>
<li><img src="basic_theory_bcd.png" alt=""></li>
</ul></li>
<li>ゾーン 10 進数
<ul>
<li>1 バイト(8 ビット) で 10 進数の 1 桁を表現する方法</li>
<li>1 バイトのうち
<ul>
<li>上位 4 ビットを「ゾーンビット」 といい「0011」や「1111」など、コンピュータ固有に定められた値を持つ
<ul>
<li>最下位桁のゾーンビットは「符号ビット」といい、正負の符号を表現する役割を持っている
<ul>
<li>正
<ul>
<li>1100</li>
</ul></li>
<li>負
<ul>
<li>1101</li>
</ul></li>
</ul></li>
</ul></li>
<li>下位 4 ビットは BCD と同じ方式で 0 〜 9 の数値を表現</li>
</ul></li>
<li><img src="basic_theory_zone_10.png" alt=""></li>
</ul></li>
<li>パック 10 進数
<ul>
<li>4 ビットで 10 進数の 1 桁を表現する方法</li>
<li>最下位桁の 4 ビットは正負の符号を表す
<ul>
<li>正
<ul>
<li>1100</li>
</ul></li>
<li>負
<ul>
<li>1101</li>
</ul></li>
</ul></li>
<li>数値が偶数桁の場合だけ、先頭の 4 ビットに 「0000」 を追加し、全体をバイト単位にする</li>
<li><img src="basic_theory_pack_10.png" alt=""></li>
</ul></li>
</ul></li>
<li>正負の表現方法
<ul>
<li>2 進数で負の数値を表現させる場合、最上位のビットを符号ビットとして扱ったり、すべてのビットを反転させる「補数」という考え方を使う</li>
<li>正負の表現方法
<ul>
<li>絶対値表現
<ul>
<li>最上位のビットを符号ビットとする</li>
<li>正
<ul>
<li>0</li>
</ul></li>
<li>負
<ul>
<li>1</li>
</ul></li>
<li>8 ビットで数値を表現する場合、最上位 1 ビットで符号を、残り 7 ビットで数値を表す
<ul>
<li><img src="basic_theory_plus_minus_absolute.png" alt=""></li>
<li>-127 〜 127 までを表現できる</li>
</ul></li>
</ul></li>
<li>補数表現
<ul>
<li>1 の補数
<ul>
<li>ある正の数を表すビット列をすべて反転させた表現形式のことで、これを負の数として定義</li>
<li>8 ビットで数値を表現する場合は、 1 の補数では 0 を表すために 00000000 と 11111111 の 2 種類があるため、- 127 〜 127 まで表現できる
<ul>
<li><img src="basic_theory_complement_1.png" alt=""></li>
</ul></li>
</ul></li>
<li>2 の補数
<ul>
<li>ある正の数を表すビット列をすべて反転させ、1 を加算した表現形式のことで、これを負の数として定義する</li>
<li>8 ビットで数値を表現する場合は、2 の補数では 0 を表すために 00000000 のひとつしか存在しないため、- 128 〜 127 までを表現できる
<ul>
<li><img src="basic_theory_complement_2.png" alt=""></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>小数の表現方法
<ul>
<li>固定小数点数
<ul>
<li>小数点の位置を特定の位置に固定して数値を表現する方法</li>
<li>小数部の位置を固定することで、整数部と小数部のビット数はそれぞれ限られるため、大きな数値や小さな数値を表現することが難しくなる</li>
<li>符号なし固定小数点
<ul>
<li>負の数を表現できない</li>
</ul></li>
<li>符号付き固定小数点
<ul>
<li>最上位ビットが正負の符号ビットになる</li>
</ul></li>
</ul></li>
<li>浮動小数点数
<ul>
<li>小数点の位置を移動してより詳細な数値を表現する方法のこと</li>
<li>8 ビット浮動小数点数の構成
<ul>
<li><img src="basic_theory_floating-point_number.png" alt=""></li>
</ul></li>
<li>一般的に浮動小数点数は、小数点の直後に 0 以外の数値が並ぶように調整して表現
<ul>
<li>浮動小数点数の正規化
<ul>
<li><img src="basic_theory_floating-point_number_normalization.png" alt=""></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol></li>
<li><p>誤差</p>
<ul>
<li>コンピュータ内部では、数値表現に使えるビット数が決まっているため、演算結果に「誤差」が生じる</li>
</ul>
<ol>
<li>丸め誤差
<ul>
<li>浮動小数点の演算結果について、最小の桁よりも小さい部分の四捨五入、切り上げまたは切り捨てを行なうことによって生じる誤差</li>
</ul></li>
<li>桁落ち
<ul>
<li>値のほぼ等しい二つの数値の差を求めた時に、有効桁数が減ることによって発生する誤差</li>
<li>有効桁数を仮数部 4 桁とした場合
<ul>
<li>0.2352 - 0.2351 = 0.0001</li>
<li>正規化すると 0.1000 * 10の-3乗</li>
<li>仮数部 4 桁で表現されていた情報が 1 桁の情報に変わる</li>
<li>仮数部下 3 桁の 0 は数値としては信用できない値なので、数値の表現力としては精度が下がっており、数値への信頼度も下がる</li>
</ul></li>
</ul></li>
<li>情報落ち
<ul>
<li>絶対値の非常に大きな数値と小さな数値の加算や減算を行ったとき，小さい数値が計算結果に反映されないことによって発生する誤差</li>
</ul></li>
<li>オーバーフロー・アンダーフロー
<ul>
<li>オーバーフロー
<ul>
<li>演算結果が、扱える数値の最大値を超えることによって生じる誤差</li>
</ul></li>
<li>アンダーフロー
<ul>
<li>演算結果が、扱える数値の最小値を超えることによって生じる誤差
<img src="basic_theory_overflow_underflow.png" alt=""></li>
</ul></li>
</ul></li>
<li>打ち切り誤差
<ul>
<li>無限級数で表される数値の計算処理を有限項で打ち切ったことによって発生する誤差</li>
</ul></li>
</ol></li>
</ul>
<ul>
<li>カルノー図
<ul>
<li>行・列それぞれの論理変数の組合せの結果が&quot;真&quot;となる場合に「1」を、&quot;偽&quot;となる場合に「0」を、その該当セルに書きこむことで論理式を図で表す方法</li>
<li>カルノー図から論理式を導くには、表の中のすべての「1」が記入されているセルをグループ化して共通項を取り出すのですが、このグループ化は下記 3 つのルールに則っている
<ul>
<li>グループ化するすべてのセルの値は 1 であること</li>
<li>グループ化するセルの数は 2N であること</li>
<li>カルノー図の上下の端、および左右の端は連続していると考える</li>
</ul></li>
</ul></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="応用数学"></a><a href="#応用数学" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>応用数学</h3>
<ul>
<li><a href="queueing-theory">待ち行列理論</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="アルゴリズムとプログラミング"></a><a href="#アルゴリズムとプログラミング" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>アルゴリズムとプログラミング</h2>
<ul>
<li>参照呼出し(pass by reference)
<ul>
<li>引数として変数のポインタ(メモリアドレス)を渡す方法</li>
<li>呼び出された関数内で引数の内容に直接アクセスすることになるため、関数内で変数の値を上書きすると元の変数の値にも反映される</li>
</ul></li>
<li>値呼出し(call by value)
<ul>
<li>引数に変数が保持する値のコピーを入れて渡す方法</li>
<li>渡された変数は関数内でのみアクセスすることができる、関数内で値を保持する変数は新しいメモリ領域に作成されるため、上書きしても元の変数の値には反映されない</li>
</ul></li>
</ul>
<ul>
<li><p>ベストフィット方式</p>
<ul>
<li>メモリ割り当てを制御するアルゴリズム</li>
<li>空き領域の大きさ順リストを先頭から探索し、要求サイズに最も合致する空きブロックを割り当てる方式
<ul>
<li>最も合致する、とは要求サイズよりも大きく、割り当て後の残り領域が最も小さくなること</li>
</ul></li>
<li>最もフィットする領域を使用するのでメモリ割り当てごとに小さい空き領域が生じ、最終的には使用するのが難しいほど小さな領域が残る傾向がある</li>
</ul></li>
<li><p>ファーストフィット方式</p>
<ul>
<li>空きブロックをメモリの先頭から検索していき、要求サイズ以上の空きブロックが見つかった時点でそれを割り当てるアルゴリズム</li>
</ul></li>
<li><p>ワーストフィット方式</p>
<ul>
<li>ベストフィットと同様に空きブロック全体を検索後、最も大きな領域を割り当てるアルゴリズム</li>
<li>空きブロック群のうち，アドレスが下位のブロックを高い頻度で使用するので，アドレスが上位の方に大きな空きブロックが残る傾向にある</li>
</ul></li>
</ul>
<ul>
<li>オーダ
<ul>
<li>アルゴリズムの効率や問題の難しさを示す計算量</li>
<li>比較回数を表す式に含まれる項の最も高い次数を使って表現</li>
<li>探索方法
<ul>
<li>2 分探索
<ul>
<li>探索対象がキー値によってあらかじめ整列済のとき、探索範囲を 2 分割し 1 / 2 ずつ狭めていって求めるデータを探す方法</li>
<li>探索に必要な実行時間(探索回数)のオーダは log2n</li>
</ul></li>
<li>線形探索
<ul>
<li>探索対象範囲の橋から順に比較していく方法</li>
<li>n 個のデータ中に必ず探索キーがあるとき、最小比較回数は 1 回、最大は n - 1 回</li>
<li>最小と最大の平均をとって、平均比較回数は n / 2 。よってオーダは n</li>
</ul></li>
<li>ハッシュ探索
<ul>
<li>キーに対してある計算(ハッシュ関数)を施してハッシュ値を求め、その値をデータの格納位置とする方法</li>
<li>この方法では、異なるキーのデータでもハッシュ値が同じになってしまうことがある</li>
<li>探索するデータ数に関係なく格納位置が求められるので、オーダは 1</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<ul>
<li><p>相補演算</p>
<ul>
<li>集合演算によって得られる結果が互いにもう一方の演算の補集合となっている関係
<ul>
<li>A と A</li>
<li>X AND Y と NOT (X AND Y)</li>
</ul></li>
</ul></li>
<li><p>排他的論理和(XOR)</p>
<ul>
<li>2 つの入力値が異なれば真、同じであれば偽を返す論理演算</li>
<li><img src="xor.png" alt=""></li>
</ul></li>
<li><p>ハフマン符号化</p>
<ul>
<li>出現度の高い文字を短いビット列で、出現率が低い文字を長いビット列で表現することで、1文字を表現するのに使用する平均ビット長を最小とする圧縮技術</li>
</ul></li>
<li><p>後置換記法(逆ポーランド表記法)</p>
<ul>
<li>Y＝(A－B)×C
<ul>
<li>YAB－C×＝</li>
</ul></li>
<li>Y＝(A＋B)×(C－(D÷E))
<ul>
<li>YAB＋CDE÷－×＝</li>
</ul></li>
<li>A + B x C
<ul>
<li>ABCx+</li>
</ul></li>
</ul></li>
<li><p>有限オートマトン</p>
<ul>
<li>入力値と入力されたときの状態で出力値が決まる順序機械に言語を識別するアルゴリズムを与えた数学的モデル</li>
<li><img src="yuugen_otoman.png" alt="">
<ol>
<li>S1 状態から始まる</li>
<li>S1 状態で 0 を出力した時は S3 へ、1 を出力した時は S2 へ状態遷移</li>
<li>S2 状態で 0 を出力した時は S2 を維持、1 を出力した時は S1 へ状態遷移</li>
<li>S3 状態で 0 を出力した時は S2 へ状態遷移し、1 を出力した時は S3 を維持</li>
<li>入力列は S3 で受理</li>
</ol></li>
</ul></li>
</ul>
<ul>
<li><p>CRC(Cyclic Redundancy Check)</p>
<ul>
<li>巡回冗長検査という意味で、送信データから生成多項式によって誤り検出用のデータを付加して送信</li>
<li>受信側では送信側と同じ生成多項式を用いて受信データを除算し、送信されてきた誤り検出用のデータと比較することで誤りの有無を判断</li>
<li>パリティビットでは検出できなかった「バースト誤りをより複雑な生成多項式による演算を行うことで検出できる」という長所がある</li>
</ul></li>
<li><p>相関係数</p>
<ul>
<li>2 つの項目の関連度合いを示す値</li>
<li>値として -1 ～ +1 の間の実数値をとる
<ul>
<li>-1 に近ければ負の相関</li>
<li>+1 に近ければ正の相関</li>
<li>0 に近いときには 2 項目間の相関は弱いと判断
<ul>
<li>無相関</li>
</ul></li>
</ul></li>
<li>正負の方向は相関の強さには関係しないので、負の相関といっても、正に比べて関連性が弱いわけではない
<ul>
<li>相関係数の絶対値の大きさ(1 にどれだけ近いか)がそのまま相関性の強さを示す</li>
</ul></li>
<li>すべての標本点が正の傾きを持つ直線上にあるときは，相関係数が +1 になる
<ul>
<li>標本点がすべて直線上にあるということは、一方の値が決まればもう一方の値が決定するという比例関係になる
<ul>
<li>このようなケースでは相関係数は +1 となる</li>
</ul></li>
</ul></li>
<li>変量間の関係が線形であれば、何らかの関係性があることが認められ、相関係数は 0 ではなくなる</li>
<li>相関係数が負の時には、負の傾きをもつ直線周辺に標本点が集まる
<ul>
<li>非線形であれば相関係数は 0 に近づく</li>
</ul></li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="others"></a><a href="#others" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Others</h2>
<hr>
<ul>
<li>バイナリ
<ul>
<li>2 進数のこと</li>
<li>2 進数の機械語のプログラムやデータのことを <code>バイナリプログラム</code> 、 <code>バイナリデータ</code> と呼ぶ</li>
</ul></li>
</ul>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#基礎理論">基礎理論</a><ul class="toc-headings"><li><a href="#離散数学">離散数学</a></li><li><a href="#応用数学">応用数学</a></li></ul></li><li><a href="#アルゴリズムとプログラミング">アルゴリズムとプログラミング</a></li><li><a href="#others">Others</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 renoretriever</section></footer></div><script>window.fbAsyncInit = function() {FB.init({appId:'258674454985396',xfbml:true,version:'v2.7'});};(function(d, s, id){var js, fjs = d.getElementsByTagName(s)[0];if (d.getElementById(id)) {return;}js = d.createElement(s); js.id = id;js.src = '//connect.facebook.net/en_US/sdk.js';fjs.parentNode.insertBefore(js, fjs);}(document, 'script','facebook-jssdk'));
                </script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>